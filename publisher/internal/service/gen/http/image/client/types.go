// Code generated by goa v3.19.1, DO NOT EDIT.
//
// image HTTP client types
//
// Command:
// $ goa gen github.com/PingCAP-QE/ee-apps/publisher/internal/service/design -o
// ./service

package client

import (
	image "github.com/PingCAP-QE/ee-apps/publisher/internal/service/gen/image"
	goa "goa.design/goa/v3/pkg"
)

// RequestToCopyRequestBody is the type of the "image" service
// "request-to-copy" endpoint HTTP request body.
type RequestToCopyRequestBody struct {
	// source image url
	Source string `form:"source" json:"source" xml:"source"`
	// destination image url
	Destination string `form:"destination" json:"destination" xml:"destination"`
}

// RequestMultiarchCollectRequestBody is the type of the "image" service
// "request-multiarch-collect" endpoint HTTP request body.
type RequestMultiarchCollectRequestBody struct {
	// The image URL to collect
	ImageURL string `form:"image_url" json:"image_url" xml:"image_url"`
	// Suffix for the release tag
	ReleaseTagSuffix string `form:"release_tag_suffix" json:"release_tag_suffix" xml:"release_tag_suffix"`
	// Whether to run the collection asynchronously. If true, returns a request id.
	// If false or omitted, runs synchronously and returns the result directly.
	Async bool `form:"async" json:"async" xml:"async"`
}

// RequestMultiarchCollectResponseBody is the type of the "image" service
// "request-multiarch-collect" endpoint HTTP response body.
type RequestMultiarchCollectResponseBody struct {
	// Whether to run the collection asynchronously. If true, returns a request id.
	// If false or omitted, runs synchronously and returns the result directly.
	Async *bool `form:"async,omitempty" json:"async,omitempty" xml:"async,omitempty"`
	// Repository of the collected image
	Repo *string `form:"repo,omitempty" json:"repo,omitempty" xml:"repo,omitempty"`
	// Tags of the collected image
	Tags []string `form:"tags,omitempty" json:"tags,omitempty" xml:"tags,omitempty"`
	// Request id for async mode (uuidv4 format)
	RequestID *string `form:"request_id,omitempty" json:"request_id,omitempty" xml:"request_id,omitempty"`
}

// NewRequestToCopyRequestBody builds the HTTP request body from the payload of
// the "request-to-copy" endpoint of the "image" service.
func NewRequestToCopyRequestBody(p *image.RequestToCopyPayload) *RequestToCopyRequestBody {
	body := &RequestToCopyRequestBody{
		Source:      p.Source,
		Destination: p.Destination,
	}
	return body
}

// NewRequestMultiarchCollectRequestBody builds the HTTP request body from the
// payload of the "request-multiarch-collect" endpoint of the "image" service.
func NewRequestMultiarchCollectRequestBody(p *image.RequestMultiarchCollectPayload) *RequestMultiarchCollectRequestBody {
	body := &RequestMultiarchCollectRequestBody{
		ImageURL:         p.ImageURL,
		ReleaseTagSuffix: p.ReleaseTagSuffix,
		Async:            p.Async,
	}
	{
		var zero string
		if body.ReleaseTagSuffix == zero {
			body.ReleaseTagSuffix = "release"
		}
	}
	{
		var zero bool
		if body.Async == zero {
			body.Async = false
		}
	}
	return body
}

// NewRequestMultiarchCollectResultOK builds a "image" service
// "request-multiarch-collect" endpoint result from a HTTP "OK" response.
func NewRequestMultiarchCollectResultOK(body *RequestMultiarchCollectResponseBody) *image.RequestMultiarchCollectResult {
	v := &image.RequestMultiarchCollectResult{
		Async:     *body.Async,
		Repo:      body.Repo,
		RequestID: body.RequestID,
	}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}

	return v
}

// ValidateRequestMultiarchCollectResponseBody runs the validations defined on
// Request-Multiarch-CollectResponseBody
func ValidateRequestMultiarchCollectResponseBody(body *RequestMultiarchCollectResponseBody) (err error) {
	if body.Async == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("async", "body"))
	}
	if body.RequestID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.request_id", *body.RequestID, goa.FormatUUID))
	}
	return
}
