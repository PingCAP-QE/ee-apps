// Code generated by goa v3.20.0, DO NOT EDIT.
//
// devbuild HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/PingCAP-QE/ee-apps/tibuild/internal/service/design -o
// ./service

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strconv"

	devbuild "github.com/PingCAP-QE/ee-apps/tibuild/internal/service/gen/devbuild"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeListResponse returns an encoder for responses returned by the devbuild
// list endpoint.
func EncodeListResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]*devbuild.DevBuild)
		enc := encoder(ctx, w)
		body := NewListResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeListRequest returns a decoder for requests sent to the devbuild list
// endpoint.
func DecodeListRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body ListRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateListRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			page      int
			pageSize  int
			hotfix    bool
			sort      string
			createdBy *string
		)
		qp := r.URL.Query()
		{
			pageRaw := qp.Get("page")
			if pageRaw == "" {
				page = 1
			} else {
				v, err2 := strconv.ParseInt(pageRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("page", pageRaw, "integer"))
				}
				page = int(v)
			}
		}
		{
			pageSizeRaw := qp.Get("page_size")
			if pageSizeRaw == "" {
				pageSize = 30
			} else {
				v, err2 := strconv.ParseInt(pageSizeRaw, 10, strconv.IntSize)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("page_size", pageSizeRaw, "integer"))
				}
				pageSize = int(v)
			}
		}
		{
			hotfixRaw := qp.Get("hotfix")
			if hotfixRaw != "" {
				v, err2 := strconv.ParseBool(hotfixRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("hotfix", hotfixRaw, "boolean"))
				}
				hotfix = v
			}
		}
		sortRaw := qp.Get("sort")
		if sortRaw != "" {
			sort = sortRaw
		} else {
			sort = "created_at"
		}
		if !(sort == "created_at" || sort == "updated_at") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("sort", sort, []any{"created_at", "updated_at"}))
		}
		createdByRaw := qp.Get("created_by")
		if createdByRaw != "" {
			createdBy = &createdByRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewListPayload(&body, page, pageSize, hotfix, sort, createdBy)

		return payload, nil
	}
}

// EncodeListError returns an encoder for errors returned by the list devbuild
// endpoint.
func EncodeListError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *devbuild.HTTPError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewListBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateResponse returns an encoder for responses returned by the
// devbuild create endpoint.
func EncodeCreateResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*devbuild.DevBuild)
		enc := encoder(ctx, w)
		body := NewCreateResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeCreateRequest returns a decoder for requests sent to the devbuild
// create endpoint.
func DecodeCreateRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body CreateRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			dryrun bool
		)
		{
			dryrunRaw := r.URL.Query().Get("dryrun")
			if dryrunRaw != "" {
				v, err2 := strconv.ParseBool(dryrunRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("dryrun", dryrunRaw, "boolean"))
				}
				dryrun = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreatePayload(&body, dryrun)

		return payload, nil
	}
}

// EncodeCreateError returns an encoder for errors returned by the create
// devbuild endpoint.
func EncodeCreateError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *devbuild.HTTPError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *devbuild.HTTPError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetResponse returns an encoder for responses returned by the devbuild
// get endpoint.
func EncodeGetResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*devbuild.DevBuild)
		enc := encoder(ctx, w)
		body := NewGetResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetRequest returns a decoder for requests sent to the devbuild get
// endpoint.
func DecodeGetRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id   int
			sync bool
			err  error

			params = mux.Vars(r)
		)
		{
			idRaw := params["id"]
			v, err2 := strconv.ParseInt(idRaw, 10, strconv.IntSize)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("id", idRaw, "integer"))
			}
			id = int(v)
		}
		{
			syncRaw := r.URL.Query().Get("sync")
			if syncRaw != "" {
				v, err2 := strconv.ParseBool(syncRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("sync", syncRaw, "boolean"))
				}
				sync = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetPayload(id, sync)

		return payload, nil
	}
}

// EncodeGetError returns an encoder for errors returned by the get devbuild
// endpoint.
func EncodeGetError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *devbuild.HTTPError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *devbuild.HTTPError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateResponse returns an encoder for responses returned by the
// devbuild update endpoint.
func EncodeUpdateResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*devbuild.DevBuild)
		enc := encoder(ctx, w)
		body := NewUpdateResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateRequest returns a decoder for requests sent to the devbuild
// update endpoint.
func DecodeUpdateRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body UpdateRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			id     int
			dryrun bool

			params = mux.Vars(r)
		)
		{
			idRaw := params["id"]
			v, err2 := strconv.ParseInt(idRaw, 10, strconv.IntSize)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("id", idRaw, "integer"))
			}
			id = int(v)
		}
		{
			dryrunRaw := r.URL.Query().Get("dryrun")
			if dryrunRaw != "" {
				v, err2 := strconv.ParseBool(dryrunRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("dryrun", dryrunRaw, "boolean"))
				}
				dryrun = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdatePayload(&body, id, dryrun)

		return payload, nil
	}
}

// EncodeUpdateError returns an encoder for errors returned by the update
// devbuild endpoint.
func EncodeUpdateError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *devbuild.HTTPError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *devbuild.HTTPError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRerunResponse returns an encoder for responses returned by the
// devbuild rerun endpoint.
func EncodeRerunResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*devbuild.DevBuild)
		enc := encoder(ctx, w)
		body := NewRerunResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeRerunRequest returns a decoder for requests sent to the devbuild rerun
// endpoint.
func DecodeRerunRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			id     int
			dryrun bool
			err    error

			params = mux.Vars(r)
		)
		{
			idRaw := params["id"]
			v, err2 := strconv.ParseInt(idRaw, 10, strconv.IntSize)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("id", idRaw, "integer"))
			}
			id = int(v)
		}
		{
			dryrunRaw := r.URL.Query().Get("dryrun")
			if dryrunRaw != "" {
				v, err2 := strconv.ParseBool(dryrunRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("dryrun", dryrunRaw, "boolean"))
				}
				dryrun = v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewRerunPayload(id, dryrun)

		return payload, nil
	}
}

// EncodeRerunError returns an encoder for errors returned by the rerun
// devbuild endpoint.
func EncodeRerunError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *devbuild.HTTPError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRerunBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *devbuild.HTTPError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRerunInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalDevbuildDevBuildToDevBuildResponse builds a value of type
// *DevBuildResponse from a value of type *devbuild.DevBuild.
func marshalDevbuildDevBuildToDevBuildResponse(v *devbuild.DevBuild) *DevBuildResponse {
	res := &DevBuildResponse{
		ID: v.ID,
	}
	if v.Meta != nil {
		res.Meta = marshalDevbuildDevBuildMetaToDevBuildMetaResponse(v.Meta)
	}
	if v.Spec != nil {
		res.Spec = marshalDevbuildDevBuildSpecToDevBuildSpecResponse(v.Spec)
	}
	if v.Status != nil {
		res.Status = marshalDevbuildDevBuildStatusToDevBuildStatusResponse(v.Status)
	}

	return res
}

// marshalDevbuildDevBuildMetaToDevBuildMetaResponse builds a value of type
// *DevBuildMetaResponse from a value of type *devbuild.DevBuildMeta.
func marshalDevbuildDevBuildMetaToDevBuildMetaResponse(v *devbuild.DevBuildMeta) *DevBuildMetaResponse {
	res := &DevBuildMetaResponse{
		CreatedBy: v.CreatedBy,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
	}

	return res
}

// marshalDevbuildDevBuildSpecToDevBuildSpecResponse builds a value of type
// *DevBuildSpecResponse from a value of type *devbuild.DevBuildSpec.
func marshalDevbuildDevBuildSpecToDevBuildSpecResponse(v *devbuild.DevBuildSpec) *DevBuildSpecResponse {
	res := &DevBuildSpecResponse{
		BuildEnv:          v.BuildEnv,
		BuilderImg:        v.BuilderImg,
		Edition:           v.Edition,
		Features:          v.Features,
		GitRef:            v.GitRef,
		GitSha:            v.GitSha,
		GithubRepo:        v.GithubRepo,
		IsHotfix:          v.IsHotfix,
		IsPushGcr:         v.IsPushGcr,
		PipelineEngine:    v.PipelineEngine,
		PluginGitRef:      v.PluginGitRef,
		Product:           v.Product,
		ProductBaseImg:    v.ProductBaseImg,
		ProductDockerfile: v.ProductDockerfile,
		TargetImg:         v.TargetImg,
		Version:           v.Version,
	}

	return res
}

// marshalDevbuildDevBuildStatusToDevBuildStatusResponse builds a value of type
// *DevBuildStatusResponse from a value of type *devbuild.DevBuildStatus.
func marshalDevbuildDevBuildStatusToDevBuildStatusResponse(v *devbuild.DevBuildStatus) *DevBuildStatusResponse {
	res := &DevBuildStatusResponse{
		ErrMsg:          v.ErrMsg,
		PipelineBuildID: v.PipelineBuildID,
		PipelineStartAt: v.PipelineStartAt,
		PipelineEndAt:   v.PipelineEndAt,
		PipelineViewURL: v.PipelineViewURL,
		Status:          string(v.Status),
	}
	if v.BuildReport != nil {
		res.BuildReport = marshalDevbuildBuildReportToBuildReportResponse(v.BuildReport)
	}
	if v.PipelineViewUrls != nil {
		res.PipelineViewUrls = make([]string, len(v.PipelineViewUrls))
		for i, val := range v.PipelineViewUrls {
			res.PipelineViewUrls[i] = val
		}
	}
	if v.TektonStatus != nil {
		res.TektonStatus = marshalDevbuildTektonStatusToTektonStatusResponse(v.TektonStatus)
	}

	return res
}

// marshalDevbuildBuildReportToBuildReportResponse builds a value of type
// *BuildReportResponse from a value of type *devbuild.BuildReport.
func marshalDevbuildBuildReportToBuildReportResponse(v *devbuild.BuildReport) *BuildReportResponse {
	if v == nil {
		return nil
	}
	res := &BuildReportResponse{
		GitSha:         v.GitSha,
		PluginGitSha:   v.PluginGitSha,
		PrintedVersion: v.PrintedVersion,
	}
	if v.Binaries != nil {
		res.Binaries = make([]*BinArtifactResponse, len(v.Binaries))
		for i, val := range v.Binaries {
			res.Binaries[i] = marshalDevbuildBinArtifactToBinArtifactResponse(val)
		}
	}
	if v.Images != nil {
		res.Images = make([]*ImageArtifactResponse, len(v.Images))
		for i, val := range v.Images {
			res.Images[i] = marshalDevbuildImageArtifactToImageArtifactResponse(val)
		}
	}

	return res
}

// marshalDevbuildBinArtifactToBinArtifactResponse builds a value of type
// *BinArtifactResponse from a value of type *devbuild.BinArtifact.
func marshalDevbuildBinArtifactToBinArtifactResponse(v *devbuild.BinArtifact) *BinArtifactResponse {
	if v == nil {
		return nil
	}
	res := &BinArtifactResponse{
		Component: v.Component,
		Platform:  v.Platform,
		Sha256URL: v.Sha256URL,
		URL:       v.URL,
	}
	if v.OciFile != nil {
		res.OciFile = marshalDevbuildOciFileToOciFileResponse(v.OciFile)
	}
	if v.Sha256OciFile != nil {
		res.Sha256OciFile = marshalDevbuildOciFileToOciFileResponse(v.Sha256OciFile)
	}

	return res
}

// marshalDevbuildOciFileToOciFileResponse builds a value of type
// *OciFileResponse from a value of type *devbuild.OciFile.
func marshalDevbuildOciFileToOciFileResponse(v *devbuild.OciFile) *OciFileResponse {
	if v == nil {
		return nil
	}
	res := &OciFileResponse{
		File: v.File,
		Repo: v.Repo,
		Tag:  v.Tag,
	}

	return res
}

// marshalDevbuildImageArtifactToImageArtifactResponse builds a value of type
// *ImageArtifactResponse from a value of type *devbuild.ImageArtifact.
func marshalDevbuildImageArtifactToImageArtifactResponse(v *devbuild.ImageArtifact) *ImageArtifactResponse {
	if v == nil {
		return nil
	}
	res := &ImageArtifactResponse{
		Platform: v.Platform,
		URL:      v.URL,
	}

	return res
}

// marshalDevbuildTektonStatusToTektonStatusResponse builds a value of type
// *TektonStatusResponse from a value of type *devbuild.TektonStatus.
func marshalDevbuildTektonStatusToTektonStatusResponse(v *devbuild.TektonStatus) *TektonStatusResponse {
	if v == nil {
		return nil
	}
	res := &TektonStatusResponse{}
	if v.Pipelines != nil {
		res.Pipelines = make([]*TektonPipelineResponse, len(v.Pipelines))
		for i, val := range v.Pipelines {
			res.Pipelines[i] = marshalDevbuildTektonPipelineToTektonPipelineResponse(val)
		}
	} else {
		res.Pipelines = []*TektonPipelineResponse{}
	}

	return res
}

// marshalDevbuildTektonPipelineToTektonPipelineResponse builds a value of type
// *TektonPipelineResponse from a value of type *devbuild.TektonPipeline.
func marshalDevbuildTektonPipelineToTektonPipelineResponse(v *devbuild.TektonPipeline) *TektonPipelineResponse {
	res := &TektonPipelineResponse{
		Name:     v.Name,
		Status:   string(v.Status),
		StartAt:  v.StartAt,
		EndAt:    v.EndAt,
		GitSha:   v.GitSha,
		Platform: v.Platform,
		URL:      v.URL,
	}
	if v.Images != nil {
		res.Images = make([]*ImageArtifactResponse, len(v.Images))
		for i, val := range v.Images {
			res.Images[i] = marshalDevbuildImageArtifactToImageArtifactResponse(val)
		}
	}
	if v.OciArtifacts != nil {
		res.OciArtifacts = make([]*OciArtifactResponse, len(v.OciArtifacts))
		for i, val := range v.OciArtifacts {
			res.OciArtifacts[i] = marshalDevbuildOciArtifactToOciArtifactResponse(val)
		}
	}

	return res
}

// marshalDevbuildOciArtifactToOciArtifactResponse builds a value of type
// *OciArtifactResponse from a value of type *devbuild.OciArtifact.
func marshalDevbuildOciArtifactToOciArtifactResponse(v *devbuild.OciArtifact) *OciArtifactResponse {
	if v == nil {
		return nil
	}
	res := &OciArtifactResponse{
		Repo: v.Repo,
		Tag:  v.Tag,
	}
	if v.Files != nil {
		res.Files = make([]string, len(v.Files))
		for i, val := range v.Files {
			res.Files[i] = val
		}
	} else {
		res.Files = []string{}
	}

	return res
}

// unmarshalDevBuildRequestRequestBodyToDevbuildDevBuildRequest builds a value
// of type *devbuild.DevBuildRequest from a value of type
// *DevBuildRequestRequestBody.
func unmarshalDevBuildRequestRequestBodyToDevbuildDevBuildRequest(v *DevBuildRequestRequestBody) *devbuild.DevBuildRequest {
	res := &devbuild.DevBuildRequest{
		BuildEnv:          v.BuildEnv,
		BuilderImg:        v.BuilderImg,
		Edition:           *v.Edition,
		Features:          v.Features,
		GitRef:            *v.GitRef,
		GitSha:            v.GitSha,
		GithubRepo:        v.GithubRepo,
		IsHotfix:          v.IsHotfix,
		IsPushGcr:         v.IsPushGcr,
		PipelineEngine:    v.PipelineEngine,
		PluginGitRef:      v.PluginGitRef,
		Product:           *v.Product,
		ProductBaseImg:    v.ProductBaseImg,
		ProductDockerfile: v.ProductDockerfile,
		TargetImg:         v.TargetImg,
		Version:           *v.Version,
	}

	return res
}

// marshalDevbuildDevBuildMetaToDevBuildMetaResponseBody builds a value of type
// *DevBuildMetaResponseBody from a value of type *devbuild.DevBuildMeta.
func marshalDevbuildDevBuildMetaToDevBuildMetaResponseBody(v *devbuild.DevBuildMeta) *DevBuildMetaResponseBody {
	res := &DevBuildMetaResponseBody{
		CreatedBy: v.CreatedBy,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
	}

	return res
}

// marshalDevbuildDevBuildSpecToDevBuildSpecResponseBody builds a value of type
// *DevBuildSpecResponseBody from a value of type *devbuild.DevBuildSpec.
func marshalDevbuildDevBuildSpecToDevBuildSpecResponseBody(v *devbuild.DevBuildSpec) *DevBuildSpecResponseBody {
	res := &DevBuildSpecResponseBody{
		BuildEnv:          v.BuildEnv,
		BuilderImg:        v.BuilderImg,
		Edition:           v.Edition,
		Features:          v.Features,
		GitRef:            v.GitRef,
		GitSha:            v.GitSha,
		GithubRepo:        v.GithubRepo,
		IsHotfix:          v.IsHotfix,
		IsPushGcr:         v.IsPushGcr,
		PipelineEngine:    v.PipelineEngine,
		PluginGitRef:      v.PluginGitRef,
		Product:           v.Product,
		ProductBaseImg:    v.ProductBaseImg,
		ProductDockerfile: v.ProductDockerfile,
		TargetImg:         v.TargetImg,
		Version:           v.Version,
	}

	return res
}

// marshalDevbuildDevBuildStatusToDevBuildStatusResponseBody builds a value of
// type *DevBuildStatusResponseBody from a value of type
// *devbuild.DevBuildStatus.
func marshalDevbuildDevBuildStatusToDevBuildStatusResponseBody(v *devbuild.DevBuildStatus) *DevBuildStatusResponseBody {
	res := &DevBuildStatusResponseBody{
		ErrMsg:          v.ErrMsg,
		PipelineBuildID: v.PipelineBuildID,
		PipelineStartAt: v.PipelineStartAt,
		PipelineEndAt:   v.PipelineEndAt,
		PipelineViewURL: v.PipelineViewURL,
		Status:          string(v.Status),
	}
	if v.BuildReport != nil {
		res.BuildReport = marshalDevbuildBuildReportToBuildReportResponseBody(v.BuildReport)
	}
	if v.PipelineViewUrls != nil {
		res.PipelineViewUrls = make([]string, len(v.PipelineViewUrls))
		for i, val := range v.PipelineViewUrls {
			res.PipelineViewUrls[i] = val
		}
	}
	if v.TektonStatus != nil {
		res.TektonStatus = marshalDevbuildTektonStatusToTektonStatusResponseBody(v.TektonStatus)
	}

	return res
}

// marshalDevbuildBuildReportToBuildReportResponseBody builds a value of type
// *BuildReportResponseBody from a value of type *devbuild.BuildReport.
func marshalDevbuildBuildReportToBuildReportResponseBody(v *devbuild.BuildReport) *BuildReportResponseBody {
	if v == nil {
		return nil
	}
	res := &BuildReportResponseBody{
		GitSha:         v.GitSha,
		PluginGitSha:   v.PluginGitSha,
		PrintedVersion: v.PrintedVersion,
	}
	if v.Binaries != nil {
		res.Binaries = make([]*BinArtifactResponseBody, len(v.Binaries))
		for i, val := range v.Binaries {
			res.Binaries[i] = marshalDevbuildBinArtifactToBinArtifactResponseBody(val)
		}
	}
	if v.Images != nil {
		res.Images = make([]*ImageArtifactResponseBody, len(v.Images))
		for i, val := range v.Images {
			res.Images[i] = marshalDevbuildImageArtifactToImageArtifactResponseBody(val)
		}
	}

	return res
}

// marshalDevbuildBinArtifactToBinArtifactResponseBody builds a value of type
// *BinArtifactResponseBody from a value of type *devbuild.BinArtifact.
func marshalDevbuildBinArtifactToBinArtifactResponseBody(v *devbuild.BinArtifact) *BinArtifactResponseBody {
	if v == nil {
		return nil
	}
	res := &BinArtifactResponseBody{
		Component: v.Component,
		Platform:  v.Platform,
		Sha256URL: v.Sha256URL,
		URL:       v.URL,
	}
	if v.OciFile != nil {
		res.OciFile = marshalDevbuildOciFileToOciFileResponseBody(v.OciFile)
	}
	if v.Sha256OciFile != nil {
		res.Sha256OciFile = marshalDevbuildOciFileToOciFileResponseBody(v.Sha256OciFile)
	}

	return res
}

// marshalDevbuildOciFileToOciFileResponseBody builds a value of type
// *OciFileResponseBody from a value of type *devbuild.OciFile.
func marshalDevbuildOciFileToOciFileResponseBody(v *devbuild.OciFile) *OciFileResponseBody {
	if v == nil {
		return nil
	}
	res := &OciFileResponseBody{
		File: v.File,
		Repo: v.Repo,
		Tag:  v.Tag,
	}

	return res
}

// marshalDevbuildImageArtifactToImageArtifactResponseBody builds a value of
// type *ImageArtifactResponseBody from a value of type *devbuild.ImageArtifact.
func marshalDevbuildImageArtifactToImageArtifactResponseBody(v *devbuild.ImageArtifact) *ImageArtifactResponseBody {
	if v == nil {
		return nil
	}
	res := &ImageArtifactResponseBody{
		Platform: v.Platform,
		URL:      v.URL,
	}

	return res
}

// marshalDevbuildTektonStatusToTektonStatusResponseBody builds a value of type
// *TektonStatusResponseBody from a value of type *devbuild.TektonStatus.
func marshalDevbuildTektonStatusToTektonStatusResponseBody(v *devbuild.TektonStatus) *TektonStatusResponseBody {
	if v == nil {
		return nil
	}
	res := &TektonStatusResponseBody{}
	if v.Pipelines != nil {
		res.Pipelines = make([]*TektonPipelineResponseBody, len(v.Pipelines))
		for i, val := range v.Pipelines {
			res.Pipelines[i] = marshalDevbuildTektonPipelineToTektonPipelineResponseBody(val)
		}
	} else {
		res.Pipelines = []*TektonPipelineResponseBody{}
	}

	return res
}

// marshalDevbuildTektonPipelineToTektonPipelineResponseBody builds a value of
// type *TektonPipelineResponseBody from a value of type
// *devbuild.TektonPipeline.
func marshalDevbuildTektonPipelineToTektonPipelineResponseBody(v *devbuild.TektonPipeline) *TektonPipelineResponseBody {
	res := &TektonPipelineResponseBody{
		Name:     v.Name,
		Status:   string(v.Status),
		StartAt:  v.StartAt,
		EndAt:    v.EndAt,
		GitSha:   v.GitSha,
		Platform: v.Platform,
		URL:      v.URL,
	}
	if v.Images != nil {
		res.Images = make([]*ImageArtifactResponseBody, len(v.Images))
		for i, val := range v.Images {
			res.Images[i] = marshalDevbuildImageArtifactToImageArtifactResponseBody(val)
		}
	}
	if v.OciArtifacts != nil {
		res.OciArtifacts = make([]*OciArtifactResponseBody, len(v.OciArtifacts))
		for i, val := range v.OciArtifacts {
			res.OciArtifacts[i] = marshalDevbuildOciArtifactToOciArtifactResponseBody(val)
		}
	}

	return res
}

// marshalDevbuildOciArtifactToOciArtifactResponseBody builds a value of type
// *OciArtifactResponseBody from a value of type *devbuild.OciArtifact.
func marshalDevbuildOciArtifactToOciArtifactResponseBody(v *devbuild.OciArtifact) *OciArtifactResponseBody {
	if v == nil {
		return nil
	}
	res := &OciArtifactResponseBody{
		Repo: v.Repo,
		Tag:  v.Tag,
	}
	if v.Files != nil {
		res.Files = make([]string, len(v.Files))
		for i, val := range v.Files {
			res.Files[i] = val
		}
	} else {
		res.Files = []string{}
	}

	return res
}

// unmarshalDevBuildRequestBodyToDevbuildDevBuild builds a value of type
// *devbuild.DevBuild from a value of type *DevBuildRequestBody.
func unmarshalDevBuildRequestBodyToDevbuildDevBuild(v *DevBuildRequestBody) *devbuild.DevBuild {
	res := &devbuild.DevBuild{
		ID: *v.ID,
	}
	res.Meta = unmarshalDevBuildMetaRequestBodyToDevbuildDevBuildMeta(v.Meta)
	res.Spec = unmarshalDevBuildSpecRequestBodyToDevbuildDevBuildSpec(v.Spec)
	res.Status = unmarshalDevBuildStatusRequestBodyToDevbuildDevBuildStatus(v.Status)

	return res
}

// unmarshalDevBuildMetaRequestBodyToDevbuildDevBuildMeta builds a value of
// type *devbuild.DevBuildMeta from a value of type *DevBuildMetaRequestBody.
func unmarshalDevBuildMetaRequestBodyToDevbuildDevBuildMeta(v *DevBuildMetaRequestBody) *devbuild.DevBuildMeta {
	res := &devbuild.DevBuildMeta{
		CreatedBy: *v.CreatedBy,
		CreatedAt: *v.CreatedAt,
		UpdatedAt: *v.UpdatedAt,
	}

	return res
}

// unmarshalDevBuildSpecRequestBodyToDevbuildDevBuildSpec builds a value of
// type *devbuild.DevBuildSpec from a value of type *DevBuildSpecRequestBody.
func unmarshalDevBuildSpecRequestBodyToDevbuildDevBuildSpec(v *DevBuildSpecRequestBody) *devbuild.DevBuildSpec {
	res := &devbuild.DevBuildSpec{
		BuildEnv:          v.BuildEnv,
		BuilderImg:        v.BuilderImg,
		Edition:           *v.Edition,
		Features:          v.Features,
		GitRef:            *v.GitRef,
		GitSha:            v.GitSha,
		GithubRepo:        v.GithubRepo,
		IsHotfix:          v.IsHotfix,
		IsPushGcr:         v.IsPushGcr,
		PipelineEngine:    v.PipelineEngine,
		PluginGitRef:      v.PluginGitRef,
		Product:           *v.Product,
		ProductBaseImg:    v.ProductBaseImg,
		ProductDockerfile: v.ProductDockerfile,
		TargetImg:         v.TargetImg,
		Version:           *v.Version,
	}

	return res
}

// unmarshalDevBuildStatusRequestBodyToDevbuildDevBuildStatus builds a value of
// type *devbuild.DevBuildStatus from a value of type
// *DevBuildStatusRequestBody.
func unmarshalDevBuildStatusRequestBodyToDevbuildDevBuildStatus(v *DevBuildStatusRequestBody) *devbuild.DevBuildStatus {
	res := &devbuild.DevBuildStatus{
		ErrMsg:          v.ErrMsg,
		PipelineBuildID: v.PipelineBuildID,
		PipelineStartAt: v.PipelineStartAt,
		PipelineEndAt:   v.PipelineEndAt,
		PipelineViewURL: v.PipelineViewURL,
		Status:          devbuild.BuildStatus(*v.Status),
	}
	if v.BuildReport != nil {
		res.BuildReport = unmarshalBuildReportRequestBodyToDevbuildBuildReport(v.BuildReport)
	}
	if v.PipelineViewUrls != nil {
		res.PipelineViewUrls = make([]string, len(v.PipelineViewUrls))
		for i, val := range v.PipelineViewUrls {
			res.PipelineViewUrls[i] = val
		}
	}
	if v.TektonStatus != nil {
		res.TektonStatus = unmarshalTektonStatusRequestBodyToDevbuildTektonStatus(v.TektonStatus)
	}

	return res
}

// unmarshalBuildReportRequestBodyToDevbuildBuildReport builds a value of type
// *devbuild.BuildReport from a value of type *BuildReportRequestBody.
func unmarshalBuildReportRequestBodyToDevbuildBuildReport(v *BuildReportRequestBody) *devbuild.BuildReport {
	if v == nil {
		return nil
	}
	res := &devbuild.BuildReport{
		GitSha:         v.GitSha,
		PluginGitSha:   v.PluginGitSha,
		PrintedVersion: v.PrintedVersion,
	}
	if v.Binaries != nil {
		res.Binaries = make([]*devbuild.BinArtifact, len(v.Binaries))
		for i, val := range v.Binaries {
			res.Binaries[i] = unmarshalBinArtifactRequestBodyToDevbuildBinArtifact(val)
		}
	}
	if v.Images != nil {
		res.Images = make([]*devbuild.ImageArtifact, len(v.Images))
		for i, val := range v.Images {
			res.Images[i] = unmarshalImageArtifactRequestBodyToDevbuildImageArtifact(val)
		}
	}

	return res
}

// unmarshalBinArtifactRequestBodyToDevbuildBinArtifact builds a value of type
// *devbuild.BinArtifact from a value of type *BinArtifactRequestBody.
func unmarshalBinArtifactRequestBodyToDevbuildBinArtifact(v *BinArtifactRequestBody) *devbuild.BinArtifact {
	if v == nil {
		return nil
	}
	res := &devbuild.BinArtifact{
		Component: v.Component,
		Platform:  v.Platform,
		Sha256URL: v.Sha256URL,
		URL:       v.URL,
	}
	if v.OciFile != nil {
		res.OciFile = unmarshalOciFileRequestBodyToDevbuildOciFile(v.OciFile)
	}
	if v.Sha256OciFile != nil {
		res.Sha256OciFile = unmarshalOciFileRequestBodyToDevbuildOciFile(v.Sha256OciFile)
	}

	return res
}

// unmarshalOciFileRequestBodyToDevbuildOciFile builds a value of type
// *devbuild.OciFile from a value of type *OciFileRequestBody.
func unmarshalOciFileRequestBodyToDevbuildOciFile(v *OciFileRequestBody) *devbuild.OciFile {
	if v == nil {
		return nil
	}
	res := &devbuild.OciFile{
		File: *v.File,
		Repo: *v.Repo,
		Tag:  *v.Tag,
	}

	return res
}

// unmarshalImageArtifactRequestBodyToDevbuildImageArtifact builds a value of
// type *devbuild.ImageArtifact from a value of type *ImageArtifactRequestBody.
func unmarshalImageArtifactRequestBodyToDevbuildImageArtifact(v *ImageArtifactRequestBody) *devbuild.ImageArtifact {
	if v == nil {
		return nil
	}
	res := &devbuild.ImageArtifact{
		Platform: *v.Platform,
		URL:      *v.URL,
	}

	return res
}

// unmarshalTektonStatusRequestBodyToDevbuildTektonStatus builds a value of
// type *devbuild.TektonStatus from a value of type *TektonStatusRequestBody.
func unmarshalTektonStatusRequestBodyToDevbuildTektonStatus(v *TektonStatusRequestBody) *devbuild.TektonStatus {
	if v == nil {
		return nil
	}
	res := &devbuild.TektonStatus{}
	res.Pipelines = make([]*devbuild.TektonPipeline, len(v.Pipelines))
	for i, val := range v.Pipelines {
		res.Pipelines[i] = unmarshalTektonPipelineRequestBodyToDevbuildTektonPipeline(val)
	}

	return res
}

// unmarshalTektonPipelineRequestBodyToDevbuildTektonPipeline builds a value of
// type *devbuild.TektonPipeline from a value of type
// *TektonPipelineRequestBody.
func unmarshalTektonPipelineRequestBodyToDevbuildTektonPipeline(v *TektonPipelineRequestBody) *devbuild.TektonPipeline {
	res := &devbuild.TektonPipeline{
		Name:     *v.Name,
		Status:   devbuild.BuildStatus(*v.Status),
		StartAt:  v.StartAt,
		EndAt:    v.EndAt,
		GitSha:   v.GitSha,
		Platform: v.Platform,
		URL:      v.URL,
	}
	if v.Images != nil {
		res.Images = make([]*devbuild.ImageArtifact, len(v.Images))
		for i, val := range v.Images {
			res.Images[i] = unmarshalImageArtifactRequestBodyToDevbuildImageArtifact(val)
		}
	}
	if v.OciArtifacts != nil {
		res.OciArtifacts = make([]*devbuild.OciArtifact, len(v.OciArtifacts))
		for i, val := range v.OciArtifacts {
			res.OciArtifacts[i] = unmarshalOciArtifactRequestBodyToDevbuildOciArtifact(val)
		}
	}

	return res
}

// unmarshalOciArtifactRequestBodyToDevbuildOciArtifact builds a value of type
// *devbuild.OciArtifact from a value of type *OciArtifactRequestBody.
func unmarshalOciArtifactRequestBodyToDevbuildOciArtifact(v *OciArtifactRequestBody) *devbuild.OciArtifact {
	if v == nil {
		return nil
	}
	res := &devbuild.OciArtifact{
		Repo: *v.Repo,
		Tag:  *v.Tag,
	}
	res.Files = make([]string, len(v.Files))
	for i, val := range v.Files {
		res.Files[i] = val
	}

	return res
}
